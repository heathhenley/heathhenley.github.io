<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>ocaml on Blogging by Heath™</title><link>https://heathhenley.dev/tags/ocaml/</link><description>Recent content in ocaml on Blogging by Heath™</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><lastBuildDate>Sun, 17 Nov 2024 10:09:15 -0500</lastBuildDate><atom:link href="https://heathhenley.dev/tags/ocaml/index.xml" rel="self" type="application/rss+xml"/><item><title>Notes on tail recursion</title><link>https://heathhenley.dev/posts/notes-tail-recursion/</link><pubDate>Sun, 17 Nov 2024 10:09:15 -0500</pubDate><guid>https://heathhenley.dev/posts/notes-tail-recursion/</guid><description>TL;DR: re-write the recursive function so that the 1st call doesn&amp;rsquo;t need to wait for the result from the remaining calls, all the way down to the base case, before returning.
Recursive functions continue calling themselves until the base case it hit - and then return. The continued calls keep pushing frames onto the stack and can lead to a stack overflow for big problems. Some languages include an optimization that cleans this up, provided that the function is written in a way that it doesn&amp;rsquo;t need to weight for the results for all the other recursive calls to resolve to return.</description></item></channel></rss>