<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>ocaml on Blogging by Heath™</title><link>https://heathhenley.dev/tags/ocaml/</link><description>Recent content in ocaml on Blogging by Heath™</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><lastBuildDate>Sun, 17 Nov 2024 10:09:15 -0500</lastBuildDate><atom:link href="https://heathhenley.dev/tags/ocaml/index.xml" rel="self" type="application/rss+xml"/><item><title>Simple tail recursion examples</title><link>https://heathhenley.dev/posts/notes-tail-recursion/</link><pubDate>Sun, 17 Nov 2024 10:09:15 -0500</pubDate><guid>https://heathhenley.dev/posts/notes-tail-recursion/</guid><description>TL;DR: re-write the recursive function so that the 1st call doesn&amp;rsquo;t need to wait for the result from the remaining calls, all the way down to the base case, before returning.
Recursive functions continue calling themselves until the base case is hit - and then they return. The continued calls keep pushing frames onto the stack and can lead to a stack overflow for large inputs. Some languages include an optimization that cleans this up, provided that the function is written in a way that it doesn&amp;rsquo;t need to wait for the results for all the other recursive calls to resolve to return.</description></item></channel></rss>