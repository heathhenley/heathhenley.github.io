<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>algorithms on Blogging by Heath™</title><link>https://heathhenley.dev/tags/algorithms/</link><description>Recent content in algorithms on Blogging by Heath™</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><lastBuildDate>Tue, 18 Mar 2025 19:07:23 -0400</lastBuildDate><atom:link href="https://heathhenley.dev/tags/algorithms/index.xml" rel="self" type="application/rss+xml"/><item><title>Random dice game - simulations and optimal strategy using dynamic programming</title><link>https://heathhenley.dev/posts/dice-game-optimal/</link><pubDate>Tue, 18 Mar 2025 19:07:23 -0400</pubDate><guid>https://heathhenley.dev/posts/dice-game-optimal/</guid><description>TL;DR: I saw a random dice game on social media with no satisfying solutions in the comments, so I played around with it using simulation to test my intuition and then worked out the optimal strategy using dynamic programming.
The game The game has $n$ rounds. You start with $0$ dollars and a 20 sided die (d20) showing the number $1$. Each round, you can take money equal to the number shown, or reroll.</description></item><item><title>Simple tail recursion examples</title><link>https://heathhenley.dev/posts/notes-tail-recursion/</link><pubDate>Sun, 17 Nov 2024 10:09:15 -0500</pubDate><guid>https://heathhenley.dev/posts/notes-tail-recursion/</guid><description>TL;DR: re-write the recursive function so that the 1st call doesn&amp;rsquo;t need to wait for the result from the remaining calls, all the way down to the base case, before returning.
Recursive functions continue calling themselves until the base case is hit - and then they return. The continued calls keep pushing frames onto the stack and can lead to a stack overflow for large inputs. Some languages include an optimization that cleans this up, provided that the function is written in a way that it doesn&amp;rsquo;t need to wait for the results for all the other recursive calls to resolve to return.</description></item><item><title>Memoization in the Wild</title><link>https://heathhenley.dev/posts/memoization-in-the-wild/</link><pubDate>Mon, 02 Aug 2021 17:32:43 -0400</pubDate><guid>https://heathhenley.dev/posts/memoization-in-the-wild/</guid><description>Overview Memoization or memoisation is a method used to optimize programs. Usually, at least in my experience, it’s one of the first topics introduced when dynamic programming algorithms are being discussed. With a quick google search you can find the Wiki or a trillion other blogs about it - most will show the canonical example - the “hello world” of the topic - that is, using memoization to optimize a recursive implementation of a function that generates the n-th Fibonacci number (or sometimes a function computing factorials).</description></item><item><title>Triplet Counting Algorithmic Puzzle</title><link>https://heathhenley.dev/posts/triplet-counting-algorithm-puzzle/</link><pubDate>Wed, 15 Apr 2020 21:05:24 -0400</pubDate><guid>https://heathhenley.dev/posts/triplet-counting-algorithm-puzzle/</guid><description>We’ve all got a little more time on our hands lately due to social distancing and COVID-19 (unless you have young children). I’ve been partly entertaining myself by learning new programming languages and frameworks, and also with some programming puzzles on sites like HackerRank.
I found one problem I ran into recently particularly interesting, and I enjoyed figuring it out (read: drove me crazy for a bit). This post is a write up of the problem and the solution that I ended up with.</description></item></channel></rss>